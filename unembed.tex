\documentclass[10pt,a4paper]{article}
%\usepackage{fullpage}
\usepackage{fancyvrb}
%\usepackage[latin1]{inputenc}
\usepackage[normalem]{ulem}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{framed}
\usepackage{pstricks}    %for embedding pspicture.
\usepackage{graphicx}
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=cyan]{hyperref}
% (1) choose a font that is available as T1
% for example:
\usepackage{lmodern}
\usepackage{booktabs}
% (2) specify encoding
\usepackage[T1]{fontenc}

% (3) load symbol definitions
%\usepackage{textcomp}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% needed for small caption fonts
%\usepackage[skip=2pt]{caption}

%\DeclareCaptionFormat{myformat}{\fontsize{8}{9}\selectfont#1#2#3}
%\captionsetup{format=myformat}
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\bibliographystyle{plain}

\setlength{\parindent}{0pt}


\usepackage{amsmath,amssymb, amsthm}
\usepackage{array}


% Define theorem-like environments
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}       % shares numbering with Theorem
\newtheorem{corollary}{Corollary}
\newtheorem{property}{Property}
\theoremstyle{definition}   % upright text
\newtheorem{definition}{Definition}
\theoremstyle{remark}       % upright text, italic header
\newtheorem{remark}{Remark}
\newcommand{\G}{\mathbb{G}}
\newcommand{\Zq}{\mathbb{Z}_q}
\newcommand{\Adv}{\mathsf{Adv}}
\newcommand{\Exp}{\mathsf{Exp}}
\newcommand{\unl}{\mathsf{unl}}
\newcommand{\ddh}{\mathsf{ddh}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\getsr}{\xleftarrow{\$}}
\newcommand{\hash}{H}


\title{A short note on the (in)ability to embed data into Schnorr}
\date{}

\begin{document}
\maketitle

\section{Abstract}

We demonstrate that, under already required assumptions (namely ECDLP hardness and hash function preimage resistance), the ability to embed data into a tuple $(P, \sigma)$ where $P$ is a public key and $\sigma$ a BIP340 Schnorr signature on that pubkey, can only come from:

\begin{itemize}
\item sidechannel information
\item grinding
\item revelation of secret key material
\end{itemize}

Since the second item only allows the embedding of a few bytes it is ignored, here. The first example (as an example, using symmetric key encryption, or using tweaked public keys with tweaks shared with counterparties) may be important but is not considered in this document.

\vskip 0.1in

We thus focus on the third case; and we emphasize that \textbf{this note does not prove that data cannot be embedded, but specifically that embedding data reveals the secret witness (key)}. We use a reduction argument to demonstrate that without breaking the hash preimage resistance assumption, it is not possible to embed 256 bits of data or more into the tuple $(P, \sigma)$ without at the same time revealing the secret witness. This may have implications for a currently theoretical scenario in which Bitcoin outputs (utxos) are accompanied by a proof of knowledge in the form of such a Schnorr signature.

\section{Introduction}

This note was motivated by the question of how one can and cannot embed data into the Bitcoin utxo set.

\vskip 0.2in

We emphasize that this focus removes the question of data embedded in the witness section of transactions, and OP\_RETURN is also considered out of scope here, as that is utxo-set-prunable.

It is trivially possible to embed data into a single pubkey $P$, if the serialized key is only checked by checking its validity; approximately half of the 256 bit values between 1 and $p$ (where $p$ is the order of the secp256k1 underlying field) are $x$-coordinates that represent valid curve points. Thus one can easily embed close to 32 bytes of arbitrary data.

An obvious side point is that if the pubkey $P$ is hashed, as it most commonly is for scriptPubKeys not using taproot, the same is true: the validity of the underlying pubkey here is not even checked, but as per the above it makes little difference, if the hash is also $\sim 32$ bytes.

\vskip 0.2in

\emph{The hypothetical scenario we here address is}: what if we try to avoid that, by forcing the publisher to prove knowledge of the preimage of $P$? Would we thus prevent such data publishing being possible? The rest of this note attempts to answer that question.

As mentioned in the abstract, if some data is transferred via a sidechannel, this can certainly allow other data to be embedded into blockchain data. But from here, we focus in on the third case: attempts to embed data, without sidechannels, and without grinding:

\vskip 0.2in

Data can effectively be embedded in signatures by using a publically-inferrable nonce, as was noted \href{https://groups.google.com/g/bitcoindev/c/d6ZO7gXGYbQ/m/Y8BfxMVxAAAJ}{here} and was later fleshed out in detail \href{https://blog.bitmex.com/the-unstoppable-jpg-in-private-keys/}{here} (\textbf{note}: both these sources discuss nonce-reuse but it's worse than that: any \emph{publically inferrable} nonce can achieve the same thing, such as, the block hash of the parent block; this will have the same embedding rate and cannot be disallowed). This technique has a poor embedding rate (it's about 33\% of the size of a tuple $(P, (R, s))$), because we leak one 32 byte value out of a total of 32+64 bytes) but is otherwise effective at combatting censorship. However it has another flaw that is crucial in our context: it allows the data to be immediately removed from the utxo set by adversaries (since the private key is published). In the remainder, we try to analyze and then formalize the significance of this.

\subsection{Goal}

Given the above context, we tighten our goal to: we wish to prove that embedding data into a combination $(P, \sigma)$ where $\sigma$ is a Schnorr pubkey-prefixed signature on the key $P$, is impossible beside grinding, \uline{if the owner wishes to keep control of the output} (so as to keep it in the utxo set and/or spend it themselves at a later time).

\vskip 0.2in

We thus consider an adversary publishing outputs formatted as: $(P, \sigma)$ with $\sigma = (R, s)$ a standard BIP340 Schnorr signature.

\vskip 0.2in

For simplicity we assume that the message signed over is "" (important note: since this signature type is pubkey prefixed, we already commit to the key (unlike in ECDSA signatures; see the final section of the document for more discussion on that).

\vskip 0.2in

And we try to answer the question: can you embed data at a more than trivial rate (through grinding, as is seen in e.g. vanity addresses) while creating such valid, signer-controlled outputs?

\section{Proving unembeddability}

The adversary wishing to leak data via a single output defined as $(P, \sigma)$ will have to win the game PubUnEmbeddable($\lambda, \G, H$) (see Table~\ref{tab:pubunembed}). Some notes on its structure:

\begin{itemize}
  \item the challenger will provide the message $\mu$ representing the data to be published. This models the idea that we are only really concerned about an adversary with the power to publish anything it chooses, rather than just some fixed message.
  \item the adversary must publish the function $f$ before it receives the data $\mu$; this is crucial mechanically of course: if it saw $\mu$ first and then could choose $f$, it would simply choose $f(..,..) = \mu$ and win. This represents the point that as per the Introduction, we want the data published to be readable without interaction with the readers; they simply need to know the ``protocol rules'' which are captured by $f$.
 \item The Adversary's response is likely surprising to the reader. He reveals the normally-private witness values $(k, x)$ such that $R =kG$ and $P=xG$, and not a tuple $(P, \sigma)$ as would be expected in a protocol to publish a key with an associated proof of knowledge (the Schnorr signature $\sigma = (R, s)$). Why is this? We assume the EUF-CMA security of Schnorr according to the normal proofs in the ROM of reducibility to ECDLP security. Thus $\nexists \ \mathcal{A}$ that can win a version of the game where $(P, (R, s))$ is returned, but cannot win this version of the game where $(k, x)$ is returned.
 \item We represent the adversary's internal algorithm as $A$, a \emph{deterministic} function on the provided $\mu$, that outputs its choice of $(k, x)$. We refer to this below as ``one-pass'' to emphasize that there is no grinding over multiple possibilities here.
\end{itemize}


\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Challenger} & \textbf{Adversary} \\
\hline
 & $\gets f:(\mathbb{G}^2, \mathbb{Z}_n) \rightarrow \mathbb{Z}_n$ \\
$\mu \leftarrow_{\$} \mathcal{D}$ ($|\mathcal{D}| = \omega(\lambda)$) & \\
$\mu \to$ & \\
 & $\gets (k, x) = A(\mu)$ \\
\hline
Construct & \\
$R = kG$, $P =xG$ & \\
$e = H(P , R, m='')$ & \\
$s = k + ex \ \ \textrm{mod}\ n$ & \\
and fail unless & \\
$f(P, R, s) = \mu$ & \\
\hline
\end{tabular}
\caption{Game PubUnEmbeddable($\lambda$, $\G$, $H$)}
\label{tab:pubunembed}
\end{table}

\begin{definition}
A Schnorr signature scheme over an elliptic curve group $\G$ and hash fn $H$ (with fixed null message) is \textbf{public-unembeddable} if, for every efficient adversary and every domain $\mathcal{D}$ of size superlogarithmic in the security parameter $\lambda$, the probability of winning the game PubUnEmbeddable($\lambda, \G, H$), without revealing the secret key $x$, is negligible.
\end{definition}

Commentary:

\begin{itemize}
\item The reader is forgiven for confusion that the definition refers to ``revealing the secret key $x$'', when the game PubUnEmbeddable has the adversary literally hand over this key. Our intention is to demonstrate that the secret key is \emph{publically calculable}, just from the transcript, $P, R, s$, however, in case the adversary wins the game.
\item We require $|\mathcal{D}|$ to have superlogarithmic entropy in the security parameter $\lambda$. For smaller domains (e.g. polynomial in $\lambda$), an adversary can exhaustively search all possible $\mu$.
\end{itemize}

\subsubsection*{Examples}

The game PubUnEmbeddable can be won by choosing $k = g(x)$ to be any function of $x$ such that $g(x) + ex$ is invertible. Here are some motivating examples:

\begin{itemize}
\item The trivial case: let $A(\mu) = (K(\mu), X(\mu))$. Let $X(\mu) = \mu$ and $K(\mu) = \mu$. This is the simplest possible way to encode $\mu$ via the secret key material. This $X$ is the identity function, and is clearly invertible. We get the function $g(x) = x$ for $k$, also the identity function, and $s = k + ex$ = $g(x) + ex$ = $(1+e)x$, which makes our $h_e(x)$ function trivially invertible: $x = \frac{s}{1 + H(P, R, '')}$.
\item The general affine case: If $g(x)=\alpha x+\beta$ with public $\alpha,\beta\in\mathbb{Z}_n$, then
\[
s \equiv (\alpha+e)x + \beta \pmod n.
\]
For all $e\not\equiv -\alpha \pmod n$,
\[
x = (s-\beta)(\alpha+e)^{-1}\pmod n,\qquad k=g(x).
\]
Thus both $x$ and $k$ are publicly extractable from one transcript. We note that due to the dependence of one variable on the other, this only represents the embedding of 256 bits of data, not 512.
\item A quadratic function. Let $X(\mu) = \mu$ and $K(\mu) = a\mu^2 + b\mu + c$, that is, $g(x) = ax^2 + bx+ c$. Then the function $f$ will be:
\[
f(P, R, s) = \left(-(b+e) \pm \sqrt{(b+e)^2 - 4a(c-s)}\right)/2a
\]
\ldots where $e = H(P, R, '')$. In this last case, notice that there are in general two solutions to the given quadratic, which cannot be fully controlled in advance since $e$ is unavoidably random; however, it has been constructed so that $x=\mu$ is always \emph{one} solution. Note also that is trivial to check if a candidate solution actually fits the signature; simply compare $xG$ with $P$.
\end{itemize}

The above examples illustrate that \textbf{if} the nonce $k$ is a function of $x$, $g(x)$, such that $g(x) + ex$ is invertible, \textbf{then} the game PubUnEmbeddable can be won. In the remainder we argue that there is no \textbf{other} way to win the game.

\begin{theorem}
\label{thm:pubunembedthm}
The BIP340 signature scheme is public-unembeddable in the ROM for SHA256.
\end{theorem}

\begin{lemma}[$k$ and $x$ are functionally related]
\label{lem:kxrelated}
If the adversary wins the game PubUnEmbeddable with non-negligible probability, then $k = g(x)$ is a function of $x$.
\end{lemma}

\begin{proof}
Without explicitly referring to the forking lemma (and thus avoiding quantitative analysis), we can see that if we wrap the challenger and fork it at the calls to $e = H(P, R, '')$, then rewind and replay any successful attempt to win the game, we get:

\[f(P, R, s_1) = f(P, R, s_2) = \mu \]
where
\[s_1 = k + e_1 x, \quad s_2 = k + e_2 x \]

Thus if $k + e_1 x = k + e_2 x$, with $e_1, e_2$ chosen unpredictably at random by the oracle (and not limited to twice, of course), it follows that $k$ must be a function of $x$ (note that it would be equivalent to define $x$ as a function of $k$ \footnote{This comment applies specifically to Schnorr, since the alternate forms $s = k + ex$ and $s = ek + x$ are functionally identical, differing only by a multiple, assuming that the inverse of $H$ has the same properties as $H$ itself. The comment does \emph{not} apply to all signature schemes, and specifically does not apply to ECDSA.}).
\end{proof}

\iffalse
\begin{lemma}[Composite invertibility]
\label{lem:compinver}
Let \( g : A \to B \) and \( h : B \to C \) be functions, and define \( f = h \circ g : A \to C \).
If \( f \) and \( g \) are invertible, then \( h \) is also invertible, with
\[
    h^{-1} = g \circ f^{-1}.
\]
\end{lemma}

\begin{proof}
Since \( f = h \circ g \), we have \( h = f \circ g^{-1} \).
Because both \( f \) and \( g^{-1} \) are bijective, their composition \( h \) is bijective as well.
Thus \( h \) is invertible, and its inverse is given by \( h^{-1} = g \circ f^{-1} \).
\end{proof}
\fi

\begin{definition}
A quick aside: we define \textbf{countably injective}, and will use this term, as the idea that a function can be reversed to find multiple possible solutions, but countably many (and computationally feasible to count). This definition is not standard but is important in practice. A simple example is that a general quadratic function $f$ has an ``inverse'' that outputs in general two possible values, not one. This is distinct from a line like $3x+y$ which has infinite pairs $x, y$ solving any specific output value.
\end{definition}

\iffalse
\begin{lemma}[Injectivity of $A$]
\label{lem:Xinjective}
Let $A$ be single-pass: on input $\mu$ it deterministically outputs
$(x,k) = (X(\mu),K(\mu))$. As per the security game, we posit the existence of an $f$ such that
$f(P,R,s)=\mu$ for all $\mu$ in a domain $\mathcal{D}$ of superlogarithmic size,
where $P=xG$, $R=kG$, and $s=k+ex$ with $e=H(P, R, m_0)$.
If such an $f$ exists, i.e. the game PubUnEmbeddable can be won with non-negligible probability, then $A$ must be injective on $\mathcal{D}$.
\end{lemma}

(Note: we do not bother to mention discrete log hardness in $\G$ here; if discrete log is not hard, then Theorem~\ref{thm:pubunembedthm} is vacuous: every signature would leak the secret witness, meaning the property public-unembeddable can never be achieved).

\begin{proof}
Let $A:\mathcal{D}\to \mathbb{Z}_n^2$, $A(\mu)=(X(\mu),K(\mu))$.
Suppose that the adversary using $A$ can win the game PubUnEmbeddable with non-negligible probability and that, for contradiction, $A$ is not injective.
Then there exist $\mu_1\neq \mu_2$ such that
\[
A(\mu_1) = A(\mu_2) = (x,k).
\]
But the transcript $(P,R,s)$ is fully determined by $(x,k)$ via
$P=xG$, $R=kG$, and $s=k+ex$. Hence both $\mu_1$ and $\mu_2$ yield
identical transcripts. In that case no function $f(P,R,s)$ can
distinguish whether the input was $\mu_1$ or $\mu_2$, contradicting
the assumption that $f$ correctly recovers every $\mu\in\mathcal D$ (which is the winning condition for PubUnEmbeddable).
Therefore the function $A$ used by a winning adversary must be injective.
\end{proof}

(Note that the argument being ``first-pass-only'' is a way to model the idea that we cannot grind some bytes into the data by trial and error; if we allow this, then data can always be embedded, but since the work is exponential we feel at liberty to ignore this.)

\fi

\begin{theorem}[Ability to win the game PubUnEmbeddable $\Rightarrow$ Extraction]
\label{thm:extraction}
We assume Lemma~\ref{lem:kxrelated}.
Then there exists a public function $g$ such that $k=g(x)$ on the set of outputs of $A$ ($(k, x)$).
For any transcript $(P,R,s)$ with $P=xG$, $R=g(x)G$, and $s=g(x)+ex\bmod n$,
where $e=H(P\|R\|m_0)$, write
\[
s = h(x) := g(x) + e x
\]
Then $h^{-1}$ is derivable from $f$ except with negligible probability, and
\[
f = X^{-1} \circ h^{-1}
\]
, and the secret key can be extracted as $h^{-1}(s)$.
\end{theorem}

\begin{proof}
The transcript satisfies $s=g(x)+ex$; we call $s = h(x)$.

$h$ is countably injective on the domain $Z_p$: suppose it were not; then, we have $g(x_1) + e_1x_1 = g(x_2) + e_2 x_2$, with $e-$values unpredictable outputs of the hash. \textbf{Assuming preimage resistance} (or, using the ROM) of the chosen cryptographic hash function $H$ for $H(xG, kG, '')=e$, then we claim that $h$ is effectively countably-injective, though note that this does not yet imply computability of $h^{-1}$ on the codomain of $h$.

\vskip 0.1in

Since the adversary was required to produce $f(P, R, s) =  \mu$, we can write $f(P, R, h(x)) = \mu$ and $f(P, R, h(X(\mu))) = \mu$ and so $f$ is a left-inverse of the composite function $h \circ X$. Thus:

\[ f \circ h \circ X = \textrm{id}
\]
\[ f \circ \left(h \circ X\right) \circ \left(h \circ X\right)^{-1} =  \left(h \circ X \right)^{-1}
\]
\[ f = X^{-1} \circ h^{-1}
\]

Thus we can find $h^{-1}$ as $X \circ f$ and this must be computable if $f$ is computable (we generally assume the trivial $X(\mu) = \mu$; other more complex relations could be folded into $f$, after all).
\end{proof}
\vskip 0.2in
Theorem~\ref{thm:extraction} is thus proved assuming the preimage resistance of $H$, which directly implies Theorem~\ref{thm:pubunembedthm} as the specific case of $\G =$ the group secp256k1 and $H =$ SHA256.




\section{Why this analysis does not apply to ECDSA}

In the case of ECDSA, there is no intrinsic binding to the public key in the hash step. This means one can ``back-solve'' for the private key after having already passed the message through the hash function. This breaks the public-unembeddability property, as is proven in outline in the remainder:

\vskip 0.2in

Concretely, this corresponds to the reality that it is actually quite trivial in this ``$P$-unbound'' case to embed data into the signature, as was nicely illustrated in the second puzzle of Blockstream's \href{https://blockstream.com/puzzle/}{half of a puzzle} page. Just defer the choice of the private key to the end; fix $s$ to your chosen data, fix $k, R=kG$, fix $m$, and solve for the private key: $d = \frac{(sk - H(m))}{R_x}$ (\emph{note to reader: $sk$ is a product of $s$ and $k$!}). When you publish $(R, s)$ you do not leak $d$.

\vskip 0.2in

Discursively: we consider again the idea of inverting functions. Let's start with Schnorr. Suppose your goal was to extract a secret key $x$ from a given signature $s$; we have a function $f_k(x) = k + ex$ to go $x \rightarrow s$. If we want to go the other way, i.e. to invert the function, we have $x = \frac{s - k}{e}$. But because $e$ depends on $x$ you have a circular reference and cannot construct that function in reality if the hash function in $e$ behaves cryptographically. While if you tried to apply this logic to ECDSA, it fails, because as already noted, the formula for the private key is: $d = \frac{(sk - H(m))}{R_x}$, which does not have any such circular dependency; note that there is an ``implicit hash'' of the nonce in $R_x$, but there is no such hash of the signing key.

\vskip 0.2in
If we try to apply the same formal model of a game PubUnEmbeddable2 (where the 2 refers to the ECDSA, instead of Schnorr, calculation performed by the challenger in the verification step), we find that the first step, that of Lemma~\ref{lem:kxrelated} already fails. There is nowhere to fork; our hash function is now only taking constant input ''. More specifically, we cannot fork on the choice of $x$ by the adversary, at all. For this reason we cannot force the adversary to make $k$ dependent on or related to $x$, and indeed, we have just seen that we can choose $k$ entirely at random and thus hide the secret material. Casting things into the formal language, we can write $X(\mu) = \frac{\mu k - e}{r}$ with $e=H(m)$ and $r$ the x-coord of $kG$. If we then want to collide on $X(\mu_1) = X(\mu_2)$, it is easy to arrange: just choose:
\[ \mu_1 = \frac{e + \frac{r_1}{r_2}\left(\mu_2 k_2 -e\right)}{k_1}
\]
This ability to arbitrarily collide without needing a violation of preimage resistance is just another way to illustrate that we cannot extract $x$ from $\mu$ via a function inversion, and indeed that is what is seen in the previous half-a-puzzle example: the data is embedded without leaking the secret key.
 
\vskip 0.2in

We won't make a formal attempt to prove that one can recover the same security property with ECDSA, by requiring that the message $m$ include $P$ or a hash of $P$, though it seems likely that it exists. This seems uninteresting, since if a new Bitcoin consensus rule required $P$ to be accompanied by $\sigma$, then it could always be required to be BIP340 rather than a legacy signature scheme with inferior security reductions.



\end{document}
